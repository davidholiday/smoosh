package com.projectvalis.reverse_rabin;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import junit.framework.Assert;

import org.jbehave.core.annotations.BeforeScenario;
import org.jbehave.core.annotations.BeforeStories;
import org.jbehave.core.annotations.BeforeStory;
import org.jbehave.core.annotations.Given;
import org.jbehave.core.annotations.Named;
import org.jbehave.core.annotations.Then;
import org.jbehave.core.annotations.When;
import org.jbehave.core.steps.Steps;
import org.rabinfingerprint.polynomial.Polynomial;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.projectvalis.util.rabin.RabinFingerprintLong_SmooshMod;


/**
 * BDD step file for the 'can we reverse a rabin hash' experiment
 * @author snerd
 *
 */
public class ReverseRabinSteps extends Steps {
	static Logger LOGGER = LoggerFactory.getLogger(ReverseRabinSteps.class);
		
	private byte[] generatedByteARR;
	private Polynomial rabinPolynomial;
	private RabinFingerprintLong_SmooshMod fingerprinter;
	
	private List<Long> xordFingerprintAL;
	private List<Long> appendedXordFingerprintAL;
	
	
	@BeforeScenario
	public void setup() {
		rabinPolynomial = Polynomial.createIrreducible(53); 
		fingerprinter = new RabinFingerprintLong_SmooshMod(rabinPolynomial);
		
		LOGGER.info(
				"GENERATED POLYNOMIAL IS: " + rabinPolynomial.toHexString());	
	}
	
	
	
	@Given("an array of $numBytesI bytes")
	public void createByteArray(@Named("numBytesI") int numBytesI) {
		Random randy = new Random();
		generatedByteARR = new byte[numBytesI];
		
		for (int i = 0; i < numBytesI; i ++) {
			generatedByteARR[i] = (byte)randy.nextInt(256);
		}
		
		String generatedBytesS = getHexString(generatedByteARR);
		LOGGER.info("GENERATED BYTES ARE: " + generatedBytesS.toUpperCase());
	}
	
	
	
	@When("the byte array is fingerprinted")
	public void fingerPrintByteArray() {
		fingerprinter.pushBytes(generatedByteARR);
	}
	


	
	@Then("the correct eight bits is appended to the head of the fingerprint "
			+ "such that\n the first [n] bits in the result are equal to the "
			+ "push table index used to \n generate the result.")
	public void checkAppendedBits() {
		
		for (int i = 0; i < appendedXordFingerprintAL.size(); i ++) {
			
			String indexBinaryS = Integer.toBinaryString(i);
			
			while (indexBinaryS.length() < 8) { 
				indexBinaryS = "0" + indexBinaryS; }
			
			Long currentFingerprintL = appendedXordFingerprintAL.get(i);
			
			String appendedHeadBits_S = 
					Long.toBinaryString(currentFingerprintL);
			
			appendedHeadBits_S = appendedHeadBits_S.substring(0, 8);
			LOGGER.info(appendedHeadBits_S + " " + appendedHeadBits_S.length());
			Assert.assertTrue(appendedHeadBits_S.length() == 8);
			LOGGER.info(indexBinaryS + " " + appendedHeadBits_S);
			Assert.assertTrue(indexBinaryS.contentEquals(appendedHeadBits_S));
		}
		
	}
	
	
	
	
	@When("the fingerprinted array is xor'd against every entry "
			+ "in the push table")
	public void xorFingerprintAll() {
		long fingerprintL = fingerprinter.getFingerprintLong();
		List<Long> polynomialL = fingerprinter.getPushTableAsList();
		
		xordFingerprintAL = polynomialL.parallelStream()
												 .map(x -> x ^ fingerprintL)
												 .collect(Collectors.toList());

		appendedXordFingerprintAL = 
				IntStream.range(0, xordFingerprintAL.size())
					.mapToObj(i -> appendByteToHead(i, xordFingerprintAL.get(i)))
					.collect(Collectors.toList());
			
	}
	

	

	
	
	@Then("it is possible to retrieve $retrieveNumI of the original "
			+ "$numBytesI bytes")
	public void retrieveBytes(@Named("retrieveNumI") int retrieveNumI,
							  @Named("numBytesI") int numBytesI) {
		
		long fingerprintL = fingerprinter.getFingerprintLong();
		
		byte[] fingerprintByteARR = 
				ByteBuffer.allocate(8).putLong(fingerprintL).array();
		
		byte[] invertedfingerprintByteARR = new byte[retrieveNumI];
		
		for (int i = 0; i < retrieveNumI; i++) {
			byte invertedB = fingerprintByteARR[i];

		}
	
		
		Assert.assertTrue("INVERSION FAILED!", 
				Arrays.equals(generatedByteARR, invertedfingerprintByteARR));
		
	}
	
	
	
	/**
	 * simple utility plucked from the interwebs to convert a byte array to 
	 * a hex string (yes I am that lazy)
	 * 
	 * yoinked from: http://www.rgagnon.com/javadetails/java-0596.html
	 * 
	 * 
	 * @param b
	 * @return
	 * @throws Exception
	 */
	public String getHexString(byte[] b) {
		  String result = "";
		  for (int i=0; i < b.length; i++) {
		    result +=
		          Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 );
		  }
		  return result;
	}
	
	
	/**
	 * 
	 * @param listIndex
	 * @param xordFingerprint
	 * @return
	 */
	public long appendByteToHead(int listIndex, long xordFingerprint) {
//		String listIndexBinaryS = Integer.toBinaryString(listIndex);
//		
//		if (listIndexBinaryS.length() > 8) {
//			listIndexBinaryS = listIndexBinaryS.substring(0, 8);
//		}
//		
//		while (listIndexBinaryS.length() < 8) { 
//			listIndexBinaryS = 0 + listIndexBinaryS; 
//		}
//LOGGER.info("listIndexBinaryS is: " + listIndexBinaryS);	
//		String xordFingerprintBinaryS = Long.toBinaryString(xordFingerprint);
//		String appendedBinaryS = listIndexBinaryS + xordFingerprintBinaryS;
//		
//		long returnValL = 
//				(appendedBinaryS.length() > 64) ? (-1) : 
//					(Long.parseLong(appendedBinaryS, 2));
//LOGGER.info("returnVal is: " + returnValL + " fingerprint is: " + xordFingerprint);
//		return returnValL;
		
	
LOGGER.info("xordFingerprint was: " + xordFingerprint);
//LOGGER.info("xordFingerprint was: " + Long.toBinaryString(xordFingerprint));
		int shiftI = Long.toBinaryString(xordFingerprint).length();
		listIndex = (listIndex & 0xFF) << shiftI;
//LOGGER.info("shiftI and listIndex are: " + shiftI + " " + Long.toBinaryString(listIndex));
LOGGER.info("xordFingerprint is:  " + (((listIndex & 0xFF) << shiftI )| xordFingerprint));
		return ( ((listIndex & 0xFF) << shiftI ) | xordFingerprint);
		
		
		/*
		 * 
		 * this guy has to return a byte array so the leading zeros don't get
		 * swallowed up.
		 * 
		 * 
		 * 
		 * 
		 */
		
		
		
	}
	
	
	
	
	
}








