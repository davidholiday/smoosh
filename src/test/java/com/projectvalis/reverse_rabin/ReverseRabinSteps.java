package com.projectvalis.reverse_rabin;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import junit.framework.Assert;

import org.jbehave.core.annotations.BeforeScenario;
import org.jbehave.core.annotations.BeforeStories;
import org.jbehave.core.annotations.BeforeStory;
import org.jbehave.core.annotations.Given;
import org.jbehave.core.annotations.Named;
import org.jbehave.core.annotations.Then;
import org.jbehave.core.annotations.When;
import org.jbehave.core.steps.Steps;
import org.rabinfingerprint.polynomial.Polynomial;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.projectvalis.util.rabin.RabinFingerprintLong_SmooshMod;


/**
 * BDD step file for the 'can we reverse a rabin hash' experiment
 * @author snerd
 *
 */
public class ReverseRabinSteps extends Steps {
	static Logger LOGGER = LoggerFactory.getLogger(ReverseRabinSteps.class);
		
	private byte[] generatedByteARR;
	private Polynomial rabinPolynomial;
	private RabinFingerprintLong_SmooshMod fingerprinter;
	
	private List<Long> xordFingerprintAL;
	private List<Long> appendedXordFingerprintAL;
	
	
	@BeforeScenario
	public void setup() {
		rabinPolynomial = Polynomial.createIrreducible(53); 
		fingerprinter = new RabinFingerprintLong_SmooshMod(rabinPolynomial);
		
		LOGGER.info(
				"GENERATED POLYNOMIAL IS: " + rabinPolynomial.toHexString());	
	}
	
	
	
	@Given("an array of $numBytesI bytes")
	public void createByteArray(@Named("numBytesI") int numBytesI) {
		Random randy = new Random();
		generatedByteARR = new byte[numBytesI];
		
		for (int i = 0; i < numBytesI; i ++) {
			generatedByteARR[i] = (byte)randy.nextInt(256);
		}
		
		String generatedBytesS = getHexString(generatedByteARR);
		LOGGER.info("GENERATED BYTES ARE: " + generatedBytesS.toUpperCase());
	}
	
	
	
	@When("the byte array is fingerprinted")
	public void fingerPrintByteArray() {
		fingerprinter.pushBytes(generatedByteARR);
	}
	


	
	@Then("the correct eight bits is appended to the head of the fingerprint "
			+ "such that\n the first [n] bits in the result are equal to the "
			+ "push table index used to \n generate the result.")
	public void checkAppendedBits() {
		
		for (int i = 0; i < appendedXordFingerprintAL.size(); i ++) {
			
//			String indexBinaryS = Integer.toBinaryString(i);
//			
//			while (indexBinaryS.length() < 8) { 
//				indexBinaryS = "0" + indexBinaryS; }
			
			Long currentFingerprintL = appendedXordFingerprintAL.get(i);

			
			int currentFingerprintHeadI = 
					(int)((currentFingerprintL >> 45) & 0x1FF);
LOGGER.info("current fingerprint: " + Long.toBinaryString(currentFingerprintL));	
LOGGER.info("current fingerprint head 8bits are: " + currentFingerprintHeadI);
			Assert.assertTrue("BITS AT HEAD OF APPENDED LIST NOT CORRECT! " + 
					"EXPECTED: " + i + " GOT: " + currentFingerprintHeadI,
					i == currentFingerprintHeadI);
			
			
//			String appendedHeadBits_S = 
//					Long.toBinaryString(currentFingerprintL);
//			
//			appendedHeadBits_S = appendedHeadBits_S.substring(0, 8);
//			LOGGER.info(appendedHeadBits_S + " " + appendedHeadBits_S.length());
//			Assert.assertTrue(appendedHeadBits_S.length() == 8);
//			LOGGER.info(indexBinaryS + " " + appendedHeadBits_S);
//			Assert.assertTrue(indexBinaryS.contentEquals(appendedHeadBits_S));
		}
		
	}
	
	
	
	
	@When("the fingerprinted array is xor'd against every entry "
			+ "in the push table")
	public void xorFingerprintAll() {
		long fingerprintL = fingerprinter.getFingerprintLong();
		List<Long> polynomialAL = fingerprinter.getPushTableAsList();
		
//		xordFingerprintAL = polynomialAL.parallelStream()
//												 .map(x -> x ^ fingerprintL)
//												 .map(x -> removeTailByte(fingerprintL))
//												 .collect(Collectors.toList());
		
		xordFingerprintAL = new ArrayList<Long>();
		appendedXordFingerprintAL = new ArrayList<Long>();
		
		for (int i = 0; i < polynomialAL.size(); i ++) {
			long xordFingerprintL = polynomialAL.get(i) ^ fingerprintL;
LOGGER.info("fingerprint and xord fingerprint are: " + fingerprintL + " " + xordFingerprintL);
			xordFingerprintL = removeTailByte(xordFingerprintL);
LOGGER.info("de-tailed xord fingerprint is: " + xordFingerprintL);
			xordFingerprintAL.add(xordFingerprintL);
			
			long appendedXordFingerprintL = appendByteToHead(i, xordFingerprintAL.get(i));
			appendedXordFingerprintAL.add(appendedXordFingerprintL);
		}
		

//		appendedXordFingerprintAL = 
//				IntStream.range(0, xordFingerprintAL.size())
//					//.filter(i -> Long.toBinaryString(xordFingerprintAL.get(i)).length() < 56)
//					.mapToObj(i -> appendByteToHead(i, xordFingerprintAL.get(i)))
//					.collect(Collectors.toList());
			
	}
	

	

	
	
	@Then("it is possible to retrieve $retrieveNumI of the original "
			+ "$numBytesI bytes")
	public void retrieveBytes(@Named("retrieveNumI") int retrieveNumI,
							  @Named("numBytesI") int numBytesI) {
		
		long fingerprintL = fingerprinter.getFingerprintLong();
		
		byte[] fingerprintByteARR = 
				ByteBuffer.allocate(8).putLong(fingerprintL).array();
		
		byte[] invertedfingerprintByteARR = new byte[retrieveNumI];
		
		for (int i = 0; i < retrieveNumI; i++) {
			byte invertedB = fingerprintByteARR[i];

		}
	
		
		Assert.assertTrue("INVERSION FAILED!", 
				Arrays.equals(generatedByteARR, invertedfingerprintByteARR));
		
	}
	
	
	
	/**
	 * simple utility plucked from the interwebs to convert a byte array to 
	 * a hex string (yes I am that lazy)
	 * 
	 * yoinked from: http://www.rgagnon.com/javadetails/java-0596.html
	 * 
	 * 
	 * @param b
	 * @return
	 * @throws Exception
	 */
	public String getHexString(byte[] b) {
		  String result = "";
		  for (int i=0; i < b.length; i++) {
		    result +=
		          Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 );
		  }
		  return result;
	}
	
	
	
	public long removeTailByte(long xordFingerprint) {
		return xordFingerprint >> 8;
	}
	
	
	
	/**
	 * 
	 * @param listIndex
	 * @param xordFingerprint
	 * @return
	 */
	public long appendByteToHead(int listIndex, long xordFingerprint) {

		// head is the bits that are indexed @ > 45 - which means they were
		// part of the value that generated the index which selected the
		// member of the push table against which this fingerprint was 
		// xor'd
		int xordFingerprintHeadLengthI = Math.abs(
				Long.toBinaryString(xordFingerprint).length() - 45);	
		
		// figure out the current value of the existing bits in head, and what
		// the delta is between what's already there and what needs to be there. 
		// then setup to update the head value accordingly.
		int xordFingerprintHeadI = (int)(xordFingerprint >> 45);
		int diffIndexAndXordHeadI = listIndex - xordFingerprintHeadI;
		xordFingerprintHeadI += diffIndexAndXordHeadI;
		
		String headBinaryS = Integer.toBinaryString(xordFingerprintHeadI);
		//while (headBinaryS.length() < 8) { headBinaryS = "0" + headBinaryS; }
		
		String headlessXordFingerprintS = 
				Long.toBinaryString(xordFingerprint).substring(xordFingerprintHeadLengthI);
		
		String appendedXordFingerprintS = headBinaryS + headlessXordFingerprintS;
		
		return Long.parseLong(appendedXordFingerprintS, 2);
			
	}
	
	
	
	
	
}








